"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _encryption = require("blockstack/lib/encryption");

var _requestPromise = _interopRequireDefault(require("request-promise"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const errorMessage = message => {
  throw new Error(`Error when validating: ${message}`);
};

let Validator =
/*#__PURE__*/
function () {
  function Validator(db, attrs, gaiaURL) {
    _classCallCheck(this, Validator);

    _defineProperty(this, "db", void 0);

    _defineProperty(this, "attrs", void 0);

    _defineProperty(this, "previous", void 0);

    _defineProperty(this, "gaiaURL", void 0);

    this.db = db;
    this.attrs = attrs;
    this.gaiaURL = gaiaURL;
  }

  _createClass(Validator, [{
    key: "validate",
    value: async function validate() {
      this.validatePresent('_id');
      await this.fetchPrevious();
      await this.validateSignature();
      await this.validatePrevious();
      await this.validateUsername();
      return true;
    }
  }, {
    key: "fetchPrevious",
    value: async function fetchPrevious() {
      const {
        _id
      } = this.attrs;
      this.previous = await this.db.findOne({
        _id
      });
    }
  }, {
    key: "validateSignature",
    value: async function validateSignature() {
      const {
        signingKeyId
      } = this.attrs.userGroupId ? this.attrs : this.previous || this.attrs;
      const {
        radiksSignature,
        updatable,
        updatedAt,
        _id
      } = this.attrs;

      if (updatable === false) {
        return true;
      }

      this.validatePresent('radiksSignature');
      this.validatePresent('signingKeyId');
      this.validatePresent('updatedAt');
      await this.signingKeyMatchesGroup();
      let signingKey;

      if (signingKeyId === 'personal') {
        const {
          publicKey
        } = this.previous || this.attrs;
        signingKey = {
          publicKey
        };
      } else {
        signingKey = await this.db.findOne({
          _id: signingKeyId
        });

        if (!signingKey) {
          errorMessage(`No signing key is present with id: '${signingKeyId}'`);
        }
      }

      const {
        publicKey
      } = signingKey;
      const message = `${_id}-${updatedAt}`;
      const isValidSignature = (0, _encryption.verifyECDSA)(message, publicKey, radiksSignature);

      if (!isValidSignature) {
        errorMessage('Invalid radiksSignature provided');
      }

      return true;
    }
  }, {
    key: "signingKeyMatchesGroup",
    value: async function signingKeyMatchesGroup() {
      if (this.attrs.userGroupId) {
        const userGroup = await this.db.findOne({
          _id: this.attrs.userGroupId
        });

        if (userGroup && userGroup.signingKeyId !== this.attrs.signingKeyId) {
          errorMessage('Signing key does not match UserGroup signing key');
        }
      }

      return true;
    }
  }, {
    key: "validatePrevious",
    value: async function validatePrevious() {
      if (this.previous && this.attrs.updatable === false) {
        errorMessage('Tried to update a non-updatable model');
      }
    }
  }, {
    key: "validatePresent",
    value: function validatePresent(key) {
      if (!this.attrs[key]) {
        errorMessage(`No '${key}' attribute, which is required.`);
      }
    }
    /**
     * If a username is included in the model attributes, then validate that
     * the model was created by the owner of the username. This is done by matching
     * the Gaia URL to any Gaia URL in that user's profile.json
     */

  }, {
    key: "validateUsername",
    value: async function validateUsername() {
      if (!(this.attrs.username && this.gaiaURL)) {
        return true;
      }

      const gaiaAddresses = await this.fetchProfileGaiaAddresses();
      const gaiaAddressParts = this.gaiaURL.split('/');
      const gaiaAddress = gaiaAddressParts[gaiaAddressParts.length - 3];
      const foundUrl = gaiaAddresses.find(address => address === gaiaAddress);

      if (!foundUrl) {
        return errorMessage('Username does not match provided Gaia URL');
      }

      return true;
    }
    /**
     * Fetch all gaia addresses from the 'apps' object in this user's profile.json
     */

  }, {
    key: "fetchProfileGaiaAddresses",
    value: async function fetchProfileGaiaAddresses() {
      const uri = `https://core.blockstack.org/v1/users/${this.attrs.username}`;

      try {
        const response = await (0, _requestPromise.default)({
          uri,
          json: true
        });
        const user = response[this.attrs.username];

        if (user && user.profile && user.profile.apps) {
          const urls = Object.values(user.profile.apps);
          return urls.map(url => {
            const parts = url.split('/');
            return parts[parts.length - 2];
          });
        }

        return [];
      } catch (error) {
        console.error(error);
        return [];
      }
    }
  }]);

  return Validator;
}();

var _default = Validator;
exports.default = _default;
module.exports = exports.default;